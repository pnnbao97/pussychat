from telegram import Update
from telegram.ext import CommandHandler, MessageHandler, filters, ContextTypes
from api import fetch_news, summarize_news, get_wiki_info, get_news_info, get_reddit_info, get_google_search_results, extract_content_from_url, analyze_with_openai
from utils import create_meme_from_image, track_id, get_chunk, check_group_id, analyze_content_with_openai, general_prompt, chatbot
from conversation import conversation_manager
from datetime import datetime
import requests
import logging
import os

logger = logging.getLogger(__name__)

ALLOWED_GROUP_ID = "-1002679588220"
ALLOWED_GROUP_ID_2 = ""
GOOGLE_API_KEY = os.getenv('GOOGLE_SEARCH')
GOOGLE_CSE_ID = os.getenv('SEARCH_ENGINE_ID')
COINGECKO_API = "https://api.coingecko.com/api/v3"

def setup_handlers(application):
    application.add_handler(CommandHandler("start", start))
    application.add_handler(CommandHandler("help", help_command))
    application.add_handler(CommandHandler("analyze", analyze_command))
    application.add_handler(CommandHandler("ask", ask_command))
    application.add_handler(CommandHandler("domestic_news", domestic_news))
    application.add_handler(CommandHandler("search", search))
    application.add_handler(CommandHandler("wiki", wiki))
    application.add_handler(CommandHandler("searchimg", searchimg))
    application.add_handler(CommandHandler("news", news))
    application.add_handler(CommandHandler("meme", meme))
    application.add_handler(CommandHandler("crypto", crypto))
    application.add_handler(CommandHandler("macro", macro))
    application.add_handler(MessageHandler(filters.TEXT & ~filters.COMMAND, handle_text))

async def start(update: Update, context: ContextTypes.DEFAULT_TYPE):
    if not await check_group_id(update, context):
        return
    await update.message.reply_text("Ch√†o tml, tao l√† con m√®o th√¥ng th√°i nh·∫•t v≈© tr·ª•. G√µ /help ƒë·ªÉ tao d·∫°y c√°ch n√≥i chuy·ªán v·ªõi tao.")

async def help_command(update: Update, context: ContextTypes.DEFAULT_TYPE):
    if not await check_group_id(update, context):
        return
    help_text = """
    ƒêm tml c√≥ m·∫•y c√¢u l·ªánh c∆° b·∫£n c≈©ng ƒë√©o nh·ªõ, ƒë·ªÉ tao nh·∫Øc l·∫°i cho m√† nghe:
    
    /search [t·ª´ kh√≥a] - N·∫øu m√†y mu·ªën tao c·∫≠p nh·∫≠t th√¥ng tin m·ªõi nh·∫•t t·ª´ nhi·ªÅu ngu·ªìn kh√°c nhau nh∆∞ wiki, reddit, google...
    /wiki [t·ª´ kh√≥a] - Ch·ªâ t√¨m ki·∫øm tr√™n Wikipedia
    /news [t·ª´ kh√≥a] - N·∫øu m√†y mu·ªën c·∫≠p nh·∫≠t th√¥ng tin b√°o ch√≠ m·ªõi nh·∫•t v·ªÅ m·ªôt ch·ªß ƒë·ªÅ...
    /analyze [url] - N·∫øu m√†y mu·ªën tao ph√¢n t√≠ch m·ªôt b√†i b√°o b·∫•t k·ª≥ th√¨ copy ƒë∆∞·ªùng d·∫´n url c√πng l·ªánh n√†y.
    /searchimg [t·ª´ kh√≥a] - Tao s·∫Ω gi√∫p m√†y t√¨m 5 t·∫•m ·∫£nh li√™n quan v·ªÅ t·ª´ kh√≥a m√†y nh·∫≠p
    /ask [tin nh·∫Øn] - N·∫øu m√†y c·∫ßn n√≥i chuy·ªán v·ªõi tao, nh∆∞ng n√≥i tr∆∞·ªõc tao c·ª•c s√∫c l·∫Øm ƒë·∫•y tml.
    /domestic_news - Tao s·∫Ω gi√∫p m√†y t√≥m t·∫Øt to√†n b·ªô nh·ªØng tin quan tr·ªçng trong ng√†y.
    /meme [text] - G·ª≠i k√®m ·∫£nh + text ƒë·ªÉ tao l√†m meme.
    /crypto [coin] - Xem gi√° coin t·ª´ CoinGecko.
    /help - Hi·ªÉn th·ªã tr·ª£ gi√∫p
    """
    await update.message.reply_text(help_text)

async def analyze_command(update: Update, context: ContextTypes.DEFAULT_TYPE):
    if not await check_group_id(update, context):
        return
    url = " ".join(context.args)
    user_id = update.message.from_user.id
    group_id = update.message.chat_id
    user_name = track_id(user_id)
    if user_name == -1:
        await update.message.reply_text(f"(ID: {user_id})\n\nƒê√¢y l√† l·∫ßn ƒë·∫ßu ti√™n tao n√≥i chuy·ªán v·ªõi m√†y, m√†y ch·ªù tao c·∫≠p nh·∫≠t c∆° s·ªü d·ªØ li·ªáu ƒë√£ nh√©!")
        return
    if not url:
        await update.message.reply_text("Nh·∫≠p url sau l·ªánh /analyze th·∫±ng ml.")
        return
    await update.message.reply_text("ƒêang truy xu·∫•t n·ªôi dung t·ª´ URL...")
    content = extract_content_from_url(url)
    if "L·ªói" in content:
        await update.message.reply_text(content)
        return
    await update.message.reply_text("ƒêang ph√¢n t√≠ch n·ªôi dung...")
    analysis = await analyze_content_with_openai(content)
    await conversation_manager.add_message(group_id, user_id, user_name, "Ph√¢n t√≠ch b√†i b√°o n√†y cho tao", analysis)
    await update.message.reply_text(f"**K·∫øt qu·∫£ ph√¢n t√≠ch**:\n{analysis}")

async def ask_command(update: Update, context: ContextTypes.DEFAULT_TYPE):
    if not await check_group_id(update, context):
        return
    question = " ".join(context.args) if context.args else ""
    user_id = update.message.from_user.id
    group_id = update.message.chat_id
    user_name = track_id(user_id)
    if user_name == -1:
        await update.message.reply_text(f"(ID: {user_id})\n\nƒê√¢y l√† l·∫ßn ƒë·∫ßu ti√™n tao n√≥i chuy·ªán v·ªõi m√†y, m√†y ch·ªù tao c·∫≠p nh·∫≠t c∆° s·ªü d·ªØ li·ªáu ƒë√£ nh√©!")
        return
    if not question:
        await update.message.reply_text("Nh·∫≠p c√¢u h·ªèi sau l·ªánh /ask th·∫±ng ml.")
        return
    response = await chatbot(question, group_id, user_id)
    await conversation_manager.add_message(group_id, user_id, user_name, question, response)
    await update.message.reply_text(response)

async def domestic_news(update: Update, context: ContextTypes.DEFAULT_TYPE):
    if not await check_group_id(update, context):
        return
    group_id = update.message.chat_id
    processing_msg = await update.message.reply_text("ƒêang thu th·∫≠p tin t·ª©c t·ª´ c√°c ngu·ªìn...")
    news_items = fetch_news()
    if not news_items:
        await context.bot.edit_message_text("Kh√¥ng t√¨m th·∫•y tin t·ª©c n√†o!", chat_id=group_id, message_id=processing_msg.message_id)
        return
    await context.bot.edit_message_text("ƒêang t√≥m t·∫Øt tin t·ª©c...", chat_id=group_id, message_id=processing_msg.message_id)
    summary = await summarize_news(news_items)
    await conversation_manager.add_message(group_id, '', '', "T√≥m t·∫Øt tin t·ª©c trong n∆∞·ªõc ng√†y h√¥m nay", summary)
    today = datetime.now().strftime("%d/%m/%Y %H:%M")
    chunk_msg = get_chunk(summary)
    await context.bot.edit_message_text(f"üì∞ T√ìM T·∫ÆT TIN T·ª®C TRONG N∆Ø·ªöC:\n‚è∞ C·∫≠p nh·∫≠t l√∫c: {today}\n\n{chunk_msg[0]}", chat_id=group_id, message_id=processing_msg.message_id)
    if len(chunk_msg) > 1:
        for i in range(1, len(chunk_msg)):
            await update.message.reply_text(chunk_msg[i])

async def search(update: Update, context: ContextTypes.DEFAULT_TYPE):
    if not await check_group_id(update, context):
        return
    query = " ".join(context.args)
    group_id = update.message.chat_id
    if not query:
        await update.message.reply_text("Nh·∫≠p ch·ªß ƒë·ªÅ m√†y mu·ªën tao truy xu·∫•t sau l·ªánh /search tml")
        return
    await update.message.reply_text(f"ƒêang t√¨m ki·∫øm th√¥ng tin v·ªÅ '{query}' t·ª´ nhi·ªÅu ngu·ªìn. ƒê·ª£i tao t√≠ nha th·∫±ng ml...")
    tasks = [
        asyncio.to_thread(get_wiki_info, query),
        asyncio.to_thread(get_news_info, query, False, 3),
        asyncio.to_thread(get_reddit_info, query, 3),
        asyncio.to_thread(get_google_search_results, query, 3)
    ]
    results = await asyncio.gather(*tasks)
    wiki_info, news_info, reddit_info, google_info = results
    
    all_info = []
    if isinstance(wiki_info, dict):
        all_info.append(wiki_info)
    else:
        all_info.append({"source": "Wikipedia", "content": wiki_info})
    if isinstance(news_info, list):
        all_info.extend(news_info)
    else:
        all_info.append({"source": "News API", "content": news_info})
    if isinstance(reddit_info, list):
        all_info.extend(reddit_info)
    else:
        all_info.append({"source": "Reddit", "content": reddit_info})
    if isinstance(google_info, list):
        all_info.extend(google_info)
    else:
        await update.message.reply_text("T·ª•i m√†y search nhi·ªÅu qu√° d√πng h·∫øt m·∫π API google r·ªìi - donate cho th·∫±ng B·∫£o ƒë·ªÉ n√≥ mua g√≥i vip nh√©")
        return
    analysis = await analyze_with_openai(query, all_info)
    await conversation_manager.add_message(group_id, '', '', f"T√¨m ki·∫øm v√† ph√¢n t√≠ch c√°c ngu·ªìn t·ª´ ch·ªß ƒë·ªÅ {query}", analysis)
    await update.message.reply_text(analysis)

async def wiki(update: Update, context: ContextTypes.DEFAULT_TYPE):
    if not await check_group_id(update, context):
        return
    query = " ".join(context.args)
    if not query:
        await update.message.reply_text("Vui l√≤ng nh·∫≠p t·ª´ kh√≥a sau l·ªánh /wiki")
        return
    await update.message.reply_text(f"ƒêang t√¨m ki·∫øm th√¥ng tin Wikipedia v·ªÅ '{query}'...")
    info = get_wiki_info(query, sentences=10)
    response = f"üìö *{info['title']}*\n\n{info['content']}\n\nNgu·ªìn: {info['url']}" if isinstance(info, dict) else info
    await update.message.reply_text(response, parse_mode='Markdown')

async def searchimg(update: Update, context: ContextTypes.DEFAULT_TYPE):
    if not await check_group_id(update, context):
        return
    query = " ".join(context.args)
    group_id = update.message.chat_id
    if not query:
        await update.message.reply_text("Nh·∫≠p t·ª´ kh√≥a v√†o tml, v√≠ d·ª•: /searchimg m√®o d·ªÖ th∆∞∆°ng")
        return
    url = f"https://www.googleapis.com/customsearch/v1?q={query}&key={GOOGLE_API_KEY}&cx={GOOGLE_CSE_ID}&searchType=image&num=5"
    response = requests.get(url)
    data = response.json()
    if "items" in data:
        for item in data["items"][:5]:
            img_url = item["link"]
            try:
                await context.bot.send_photo(chat_id=group_id, photo=img_url)
            except:
                await update.message.reply_text("Tao t√¨m ƒë∆∞·ª£c nh∆∞ng ƒë√©o g·ª≠i l√™n ƒë∆∞·ª£c, ch·∫Øc m√†y l·∫°i t√¨m ·∫£nh porn ch·ª© g√¨")
        await conversation_manager.add_message(group_id, '', '', f"T√¨m ki·∫øm ·∫£nh v·ªÅ ch·ªß ƒë·ªÅ {query}", "Pussy g·ª≠i tr·∫£ 5 ·∫£nh")
    else:
        await update.message.reply_text("Kh√¥ng t√¨m th·∫•y ·∫£nh n√†o!")

async def news(update: Update, context: ContextTypes.DEFAULT_TYPE):
    if not await check_group_id(update, context):
        return
    query = " ".join(context.args)
    if not query:
        await update.message.reply_text("Vui l√≤ng nh·∫≠p t·ª´ kh√≥a sau l·ªánh /news")
        return
    await update.message.reply_text(f"ƒêang t√¨m ki·∫øm tin t·ª©c v·ªÅ '{query}'...")
    categories = ["general", "business", "technology", "science", "health", "sports", "entertainment"]
    news = get_news_info(query, query if query in categories else False)
    if isinstance(news, list):
        for article in news:
            response = f"üì∞ *{article['title']}*\n\n{article['content'][:300]}...\n\nNgu·ªìn: {article['source']}\nNg√†y ƒëƒÉng: {article['published_at']}\nLink: {article['url']}"
            await context.bot.send_message(chat_id=update.message.chat_id, text=response, parse_mode='MarkdownV2')
    else:
        await update.message.reply_text(news)

async def meme(update: Update, context: ContextTypes.DEFAULT_TYPE):
    if not await check_group_id(update, context):
        return
    text = " ".join(context.args)
    if not text:
        await update.message.reply_text("Nh·∫≠p text ƒë·ªÉ tao l√†m meme, k√®m ·∫£nh b·∫±ng c√°ch reply ·∫£nh, ƒëm!")
        return
    
    if not update.message.reply_to_message or not update.message.reply_to_message.photo:
        await update.message.reply_text("M√†y ph·∫£i reply m·ªôt ·∫£nh k√®m text ƒë·ªÉ tao l√†m meme, ƒëm! G·ª≠i l·∫°i ƒëi!")
        return
    
    try:
        photo = update.message.reply_to_message.photo[-1]
        file = await photo.get_file()
        image_url = file.file_path
        logger.info(f"Received photo URL: {image_url}")
        
        await update.message.reply_text("ƒê·ª£i tao v·∫Ω c√°i meme t·ª´ ·∫£nh m√†y g·ª≠i...")
        meme_img = await create_meme_from_image(image_url, text)
        
        if isinstance(meme_img, str):
            await update.message.reply_text(meme_img)
        else:
            await context.bot.send_photo(chat_id=update.message.chat_id, photo=meme_img)
            logger.info("Meme sent successfully")
    except Exception as e:
        logger.error(f"Error in meme creation: {str(e)}")
        await update.message.reply_text(f"L·ªói khi x·ª≠ l√Ω ·∫£nh ho·∫∑c t·∫°o meme: {str(e)}. Th·ª≠ l·∫°i ƒëi tml!")

async def crypto(update: Update, context: ContextTypes.DEFAULT_TYPE):
    if not await check_group_id(update, context):
        return
    coin = " ".join(context.args).lower()
    if not coin:
        await update.message.reply_text("Nh·∫≠p t√™n coin ƒëi tml, v√≠ d·ª•: /crypto bitcoin")
        return
    
    user_id = update.message.from_user.id
    group_id = update.message.chat_id
    user_name = track_id(user_id)
    
    url = f"{COINGECKO_API}/coins/{coin}?localization=false&tickers=false&market_data=true&community_data=false&developer_data=false&sparkline=false"
    response = requests.get(url)
    data = response.json()
    
    if "error" in data or "id" not in data:
        await update.message.reply_text(f"ƒê√©o t√¨m th·∫•y coin '{coin}' n√†o c·∫£! Check l·∫°i t√™n coin ƒëi tml.")
        return
    
    today = datetime.now().strftime("%d/%m/%Y")
    market_data = data["market_data"]
    price = market_data["current_price"]["usd"]
    volume_24h = market_data["total_volume"]["usd"]
    market_cap = market_data["market_cap"]["usd"]
    price_change_24h = market_data["price_change_percentage_24h"]
    high_24h = market_data["high_24h"]["usd"]
    low_24h = market_data["low_24h"]["usd"]
    last_updated = market_data["last_updated"]
    
    greed_fear_url = "https://api.alternative.me/fng/?limit=1"
    greed_fear_response = requests.get(greed_fear_url)
    greed_fear_data = greed_fear_response.json()
    
    if greed_fear_data and "data" in greed_fear_data and len(greed_fear_data["data"]) > 0:
        greed_fear_value = greed_fear_data["data"][0]["value"]
        greed_fear_classification = greed_fear_data["data"][0]["value_classification"]
        greed_fear_timestamp = greed_fear_data["data"][0]["timestamp"]
        greed_fear_text = f"üò® Ch·ªâ s·ªë S·ª£ h√£i & Tham lam (Greed/Fear): {greed_fear_value} - {greed_fear_classification} (C·∫≠p nh·∫≠t: {datetime.fromtimestamp(int(greed_fear_timestamp)).strftime('%Y-%m-%d %H:%M:%S')})"
    else:
        greed_fear_text = "üò® Kh√¥ng l·∫•y ƒë∆∞·ª£c ch·ªâ s·ªë S·ª£ h√£i & Tham lam, ch·∫Øc API h·ªèng r·ªìi tml!"
    
    response_text = (
        f"üí∞ **{coin.upper()}** - C·∫≠p nh·∫≠t l√∫c: {last_updated}\n"
        f"üìà Gi√° hi·ªán t·∫°i: ${price:,.2f}\n"
        f"üìä Thay ƒë·ªïi 24h: {price_change_24h:.2f}%\n"
        f"üîù Cao nh·∫•t 24h: ${high_24h:,.2f}\n"
        f"üîª Th·∫•p nh·∫•t 24h: ${low_24h:,.2f}\n"
        f"üí∏ V·ªën h√≥a th·ªã tr∆∞·ªùng: ${market_cap:,.0f}\n"
        f"üìâ Kh·ªëi l∆∞·ª£ng giao d·ªãch 24h: ${volume_24h:,.0f}\n"
        f"{greed_fear_text}"
    )
    
    await update.message.reply_text(response_text)
    await conversation_manager.add_message(group_id, user_id, user_name, f"T√¨m th√¥ng tin ƒë·ªìng coin, c·∫≠p nh·∫≠t {today}", response_text)

async def macro(update: Update, context: ContextTypes.DEFAULT_TYPE):
    from api import get_fred_data
    if not await check_group_id(update, context):
        return
    
    user_id = update.message.from_user.id
    group_id = update.message.chat_id
    user_name = track_id(user_id)
    await update.message.reply_text("ƒê·ª£i tao moi d·ªØ li·ªáu kinh t·∫ø vƒ© m√¥ t·ª´ FRED, tml ƒë·ª´ng h·ªëi!")
    
    macro_data = []
    macro_values = {}
    
    indicators = [
        ("GDPC1", "GDP th·ª±c t·∫ø (t·ª∑ USD)", "üìà"),
        ("CPIAUCSL", "Ch·ªâ s·ªë gi√° ti√™u d√πng (CPI)", "üí∏"),
        ("FEDFUNDS", "L√£i su·∫•t Fed (%)", "üè¶"),
        ("UNRATE", "T·ª∑ l·ªá th·∫•t nghi·ªáp (%)", "üë∑‚Äç‚ôÇÔ∏è"),
        ("PAYEMS", "B·∫£ng l∆∞∆°ng phi n√¥ng nghi·ªáp (ngh√¨n ng∆∞·ªùi)", "üíº"),
        ("RSAFS", "Doanh s·ªë b√°n l·∫ª (tri·ªáu USD)", "üõí"),
        ("INDPRO", "S·∫£n xu·∫•t c√¥ng nghi·ªáp", "üè≠"),
        ("CPILFESL", "L·∫°m ph√°t l√µi (Core CPI)", "üî•"),
        ("DGS10", "L·ª£i su·∫•t tr√°i phi·∫øu 10 nƒÉm (%)", "üìú"),
        ("BOPGSTB", "C√°n c√¢n th∆∞∆°ng m·∫°i (tri·ªáu USD)", "‚öñÔ∏è"),
        ("UMCSENT", "Ni·ªÅm tin ti√™u d√πng", "üòä")
    ]
    
    today = datetime.now().strftime("%d/%m/%Y")
    for series_id, name, icon in indicators:
        text, value, date = get_fred_data(series_id, name, icon)
        macro_data.append(text)
        if value is not None:
            macro_values[name] = {"value": value, "date": date}
    
    response_text = (
        "üìä **CH·ªà S·ªê KINH T·∫æ Vƒ® M√î T·ª™ FRED** - D·ªØ li·ªáu m·ªõi nh·∫•t:\n\n" +
        "\n".join(macro_data))
    await update.message.reply_text(response_text)
    
    await update.message.reply_text("M·∫•y tml trong nh√≥m ng·ªìi im nghe tao ph√¢n t√≠ch")
    analysis_prompt = (
        "M√†y l√† m·ªôt tr·ª£ l√Ω ph√¢n t√≠ch kinh t·∫ø vƒ© m√¥, l√°o to√©t nh∆∞ng s·∫Øc b√©n. "
        "D·ª±a tr√™n c√°c ch·ªâ s·ªë kinh t·∫ø sau t·ª´ FRED, h√£y ph√¢n t√≠ch t√¨nh h√¨nh kinh t·∫ø hi·ªán t·∫°i "
        "v√† ƒë∆∞a ra nh·∫≠n x√©t ng·∫Øn g·ªçn (d∆∞·ªõi 500 t·ª´) v·ªÅ t√°c ƒë·ªông ƒë·∫øn th·ªã tr∆∞·ªùng t√†i ch√≠nh, "
        "bao g·ªìm ch·ª©ng kho√°n, USD, v√† crypto. ƒê√¢y l√† d·ªØ li·ªáu:\n\n" +
        "\n".join([f"{k}: {v['value']} (C·∫≠p nh·∫≠t: {v['date']})" for k, v in macro_values.items()]) +
        "\n\nPh√¢n t√≠ch ƒëi, ƒë·ª´ng d√†i d√≤ng!"
    )
    
    chat_history = ChatHistory()
    chat_history.add_system_message(general_prompt)
    chat_history.add_user_message(analysis_prompt)
    from api import chat_service, execution_settings
    analysis = await chat_service.get_chat_message_content(chat_history, execution_settings)
    
    await update.message.reply_text(analysis)
    await conversation_manager.add_message(group_id, user_id, user_name, "Ph√¢n t√≠ch d·ªØ li·ªáu kinh t·∫ø vƒ© m√¥", analysis)

async def handle_text(update: Update, context: ContextTypes.DEFAULT_TYPE):
    if not await check_group_id(update, context):
        return
    if not update.message.forward_origin:
        return
    if update.message.text:
        text = update.message.text
    elif update.message.caption:
        text = update.message.caption
    else: 
        return
    user_id = update.message.from_user.id
    group_id = update.message.chat_id
    user_name = track_id(user_id)
    if user_name == -1:
        await update.message.reply_text(f"(ID: {user_id})\n\nƒê√¢y l√† l·∫ßn ƒë·∫ßu ti√™n tao n√≥i chuy·ªán v·ªõi m√†y, m√†y ch·ªù tao c·∫≠p nh·∫≠t c∆° s·ªü d·ªØ li·ªáu ƒë√£ nh√©!")
        return
    question = f"{user_name} forward n·ªôi dung t·ª´ n∆°i kh√°c, k√™u Pussy ph√¢n t√≠ch: {text}"
    response = await chatbot(question, group_id, user_id)
    await conversation_manager.add_message(group_id, user_id, user_name, question, response)
    await update.message.reply_text(response)
