from telegram import Update
import asyncio
from telegram.ext import CommandHandler, MessageHandler, filters, ContextTypes
from api import fetch_news, summarize_news, get_wiki_info, get_news_info, get_reddit_info, get_google_search_results, extract_content_from_url, analyze_with_openai, analyze_with_openai
from agents import pussy_bot
from utils import track_id, get_chunk, check_group_id, analyze_image
from conversation import conversation_manager
from datetime import datetime
import requests
import logging
import os

logger = logging.getLogger(__name__)

ALLOWED_GROUP_ID = "-1002679588220"
ALLOWED_GROUP_ID_2 = ""
GOOGLE_API_KEY = os.getenv('GOOGLE_SEARCH')
GOOGLE_CSE_ID = os.getenv('SEARCH_ENGINE_ID')
COINGECKO_API = "https://api.coingecko.com/api/v3"

def setup_handlers(application):
    application.add_handler(CommandHandler("start", start))
    application.add_handler(CommandHandler("help", help_command))
    application.add_handler(CommandHandler("analyze", analyze_command))
    application.add_handler(CommandHandler("ask", ask_command))
    application.add_handler(CommandHandler("domestic_news", domestic_news))
    application.add_handler(CommandHandler("search", search))
    application.add_handler(CommandHandler("wiki", wiki))
    application.add_handler(CommandHandler("searchimg", searchimg))
    application.add_handler(CommandHandler("news", news))
    application.add_handler(CommandHandler("crypto", crypto))
    # application.add_handler(CommandHandler("macro", macro))
    application.add_handler(MessageHandler(filters.TEXT, handle_text))
    application.add_handler(MessageHandler(filters.PHOTO | (filters.PHOTO & filters.TEXT), handle_photo_or_text))

async def start(update: Update, context: ContextTypes.DEFAULT_TYPE):
    if not await check_group_id(update, context):
        return
    await update.message.reply_text("Ch√†o tml, tao l√† con m√®o th√¥ng th√°i nh·∫•t v≈© tr·ª•. G√µ /help ƒë·ªÉ tao d·∫°y c√°ch n√≥i chuy·ªán v·ªõi tao.")

async def help_command(update: Update, context: ContextTypes.DEFAULT_TYPE):
    if not await check_group_id(update, context):
        return
    help_text = """
    ƒêm tml c√≥ m·∫•y c√¢u l·ªánh c∆° b·∫£n c≈©ng ƒë√©o nh·ªõ, ƒë·ªÉ tao nh·∫Øc l·∫°i cho m√† nghe:
    
    /search [t·ª´ kh√≥a] - N·∫øu m√†y mu·ªën tao c·∫≠p nh·∫≠t th√¥ng tin m·ªõi nh·∫•t t·ª´ nhi·ªÅu ngu·ªìn kh√°c nhau nh∆∞ wiki, reddit, google...
    /wiki [t·ª´ kh√≥a] - Ch·ªâ t√¨m ki·∫øm tr√™n Wikipedia
    /news [t·ª´ kh√≥a] - N·∫øu m√†y mu·ªën c·∫≠p nh·∫≠t th√¥ng tin b√°o ch√≠ m·ªõi nh·∫•t v·ªÅ m·ªôt ch·ªß ƒë·ªÅ...
    /analyze [url] - N·∫øu m√†y mu·ªën tao ph√¢n t√≠ch m·ªôt b√†i b√°o b·∫•t k·ª≥ th√¨ copy ƒë∆∞·ªùng d·∫´n url c√πng l·ªánh n√†y.
    /searchimg [t·ª´ kh√≥a] - Tao s·∫Ω gi√∫p m√†y t√¨m 5 t·∫•m ·∫£nh li√™n quan v·ªÅ t·ª´ kh√≥a m√†y nh·∫≠p
    /ask [tin nh·∫Øn] - N·∫øu m√†y c·∫ßn n√≥i chuy·ªán v·ªõi tao, nh∆∞ng n√≥i tr∆∞·ªõc tao c·ª•c s√∫c l·∫Øm ƒë·∫•y tml.
    /domestic_news - Tao s·∫Ω gi√∫p m√†y t√≥m t·∫Øt to√†n b·ªô nh·ªØng tin quan tr·ªçng trong ng√†y.
    /crypto [coin] - Xem gi√° coin t·ª´ CoinGecko.
    /help - Hi·ªÉn th·ªã tr·ª£ gi√∫p
    """
    await update.message.reply_text(help_text)

async def analyze_command(update: Update, context: ContextTypes.DEFAULT_TYPE):
    if not await check_group_id(update, context):
        return
    url = " ".join(context.args)
    user_id = update.message.from_user.id
    group_id = update.message.chat_id
    user_name = track_id(user_id)
    if user_name == -1:
        await update.message.reply_text(f"(ID: {user_id})\n\nƒê√¢y l√† l·∫ßn ƒë·∫ßu ti√™n tao n√≥i chuy·ªán v·ªõi m√†y, m√†y ch·ªù tao c·∫≠p nh·∫≠t c∆° s·ªü d·ªØ li·ªáu ƒë√£ nh√©!")
        return
    if not url:
        await update.message.reply_text("Nh·∫≠p url sau l·ªánh /analyze th·∫±ng ml.")
        return
    processing_msg = await update.message.reply_text("ƒêang truy xu·∫•t n·ªôi dung t·ª´ URL...")
    content = extract_content_from_url(url)
    if "L·ªói" in content:
        await update.message.reply_text(content)
        return
    await context.bot.edit_message_text("ƒêang ph√¢n t√≠ch n·ªôi dung...", chat_id=group_id, message_id=processing_msg.message_id)
    analysis = await analyze_content_with_openai(content)
    await conversation_manager.add_message(group_id, user_id, user_name, "Ph√¢n t√≠ch b√†i b√°o n√†y cho tao", analysis)
    await context.bot.edit_message_text(f"**K·∫øt qu·∫£ ph√¢n t√≠ch**:\n{analysis}", chat_id=group_id, message_id=processing_msg.message_id)

async def ask_command(update: Update, context: ContextTypes.DEFAULT_TYPE):
    if not await check_group_id(update, context):
        return
    replied_message = update.message.reply_to_message
    if replied_message:
        question = replied_message.text
    else:
        question = " ".join(context.args) if context.args else ""
    user_id = update.message.from_user.id
    group_id = update.message.chat_id
    user_name = track_id(user_id)
    if user_name == -1:
        await update.message.reply_text(f"(ID: {user_id})\n\nƒê√¢y l√† l·∫ßn ƒë·∫ßu ti√™n tao n√≥i chuy·ªán v·ªõi m√†y, m√†y ch·ªù tao c·∫≠p nh·∫≠t c∆° s·ªü d·ªØ li·ªáu ƒë√£ nh√©!")
        return
    if not question:
        await update.message.reply_text("Nh·∫≠p c√¢u h·ªèi sau l·ªánh /ask th·∫±ng ml.")
        return
    response = await pussy_bot(question, group_id, user_id)
    await conversation_manager.add_message(group_id, user_id, user_name, question, response)
    await update.message.reply_text(response)

async def domestic_news(update: Update, context: ContextTypes.DEFAULT_TYPE):
    if not await check_group_id(update, context):
        return
    group_id = update.message.chat_id
    processing_msg = await update.message.reply_text("ƒêang thu th·∫≠p tin t·ª©c t·ª´ c√°c ngu·ªìn...")
    news_items = fetch_news()
    if not news_items:
        await context.bot.edit_message_text("Kh√¥ng t√¨m th·∫•y tin t·ª©c n√†o!", chat_id=group_id, message_id=processing_msg.message_id)
        return
    await context.bot.edit_message_text("ƒêang t√≥m t·∫Øt tin t·ª©c...", chat_id=group_id, message_id=processing_msg.message_id)
    summary = await summarize_news(news_items)
    await conversation_manager.add_message(group_id, '', '', "T√≥m t·∫Øt tin t·ª©c trong n∆∞·ªõc ng√†y h√¥m nay", summary)
    today = datetime.now().strftime("%d/%m/%Y %H:%M")
    chunk_msg = get_chunk(summary)
    await context.bot.edit_message_text(f"üì∞ T√ìM T·∫ÆT TIN T·ª®C TRONG N∆Ø·ªöC:\n‚è∞ C·∫≠p nh·∫≠t l√∫c: {today}\n\n{chunk_msg[0]}", chat_id=group_id, message_id=processing_msg.message_id)
    if len(chunk_msg) > 1:
        for i in range(1, len(chunk_msg)):
            await update.message.reply_text(chunk_msg[i])

async def search(update: Update, context: ContextTypes.DEFAULT_TYPE):
    if not await check_group_id(update, context):
        return
    query = " ".join(context.args)
    group_id = update.message.chat_id
    if not query:
        await update.message.reply_text("Nh·∫≠p ch·ªß ƒë·ªÅ m√†y mu·ªën tao truy xu·∫•t sau l·ªánh /search tml")
        return
    processing_msg = await update.message.reply_text(f"ƒêang t√¨m ki·∫øm th√¥ng tin v·ªÅ '{query}' t·ª´ nhi·ªÅu ngu·ªìn. H·ªëi h·ªëi c√°i l, ƒë·ª£i t t√≠...")
    tasks = [
        asyncio.to_thread(get_wiki_info, query),
        asyncio.to_thread(get_news_info, query, False, 3),
        asyncio.to_thread(get_reddit_info, query, 5),
        asyncio.to_thread(get_google_search_results, query, 5)
    ]
    results = await asyncio.gather(*tasks)
    wiki_info, news_info, reddit_info, google_info = results
    
    all_info = []
    if isinstance(wiki_info, dict):
        all_info.append(wiki_info)
    else:
        all_info.append({"source": "Wikipedia", "content": wiki_info})
    if isinstance(news_info, list):
        all_info.extend(news_info)
    else:
        all_info.append({"source": "News API", "content": news_info})
    if isinstance(reddit_info, list):
        all_info.extend(reddit_info)
    else:
        all_info.append({"source": "Reddit", "content": reddit_info})
    if isinstance(google_info, list):
        all_info.extend(google_info)
    else:
        await context.bot.edit_message_text("T·ª•i m√†y search nhi·ªÅu qu√° d√πng h·∫øt m·∫π API google r·ªìi - donate cho th·∫±ng B·∫£o ƒë·ªÉ n√≥ mua g√≥i vip nh√©", chat_id=group_id, message_id=processing_msg.message_id)
        return
    analysis = await analyze_with_openai(query, all_info)
    await conversation_manager.add_message(group_id, '', '', f"T√¨m ki·∫øm v√† ph√¢n t√≠ch c√°c ngu·ªìn t·ª´ ch·ªß ƒë·ªÅ {query}", analysis)
    await context.bot.edit_message_text(analysis, chat_id=group_id, message_id=processing_msg.message_id)

async def wiki(update: Update, context: ContextTypes.DEFAULT_TYPE):
    if not await check_group_id(update, context):
        return
    query = " ".join(context.args)
    if not query:
        await update.message.reply_text("Vui l√≤ng nh·∫≠p t·ª´ kh√≥a sau l·ªánh /wiki")
        return
    await update.message.reply_text(f"ƒêang t√¨m ki·∫øm th√¥ng tin Wikipedia v·ªÅ '{query}'...")
    info = get_wiki_info(query, sentences=10)
    response = f"üìö *{info['title']}*\n\n{info['content']}\n\nNgu·ªìn: {info['url']}" if isinstance(info, dict) else info
    await update.message.reply_text(response, parse_mode='Markdown')

async def searchimg(update: Update, context: ContextTypes.DEFAULT_TYPE):
    if not await check_group_id(update, context):
        return
    query = " ".join(context.args)
    user_id = update.message.from_user.id
    group_id = update.message.chat_id
    user_name = track_id(user_id)
    if not query:
        await update.message.reply_text("Nh·∫≠p t·ª´ kh√≥a v√†o tml, v√≠ d·ª•: /searchimg m√®o d·ªÖ th∆∞∆°ng")
        return
    url = f"https://www.googleapis.com/customsearch/v1?q={query}&key={GOOGLE_API_KEY}&cx={GOOGLE_CSE_ID}&searchType=image&num=5"
    response = requests.get(url)
    data = response.json()
    if "items" in data:
        for item in data["items"][:5]:
            img_url = item["link"]
            try:
                await context.bot.send_photo(chat_id=group_id, photo=img_url)
            except:
                await update.message.reply_text("Tao t√¨m ƒë∆∞·ª£c nh∆∞ng ƒë√©o g·ª≠i l√™n ƒë∆∞·ª£c, ch·∫Øc m√†y l·∫°i t√¨m ·∫£nh porn ch·ª© g√¨")
        await conversation_manager.add_message(group_id, user_id, user_name, f"T√¨m ki·∫øm ·∫£nh v·ªÅ ch·ªß ƒë·ªÅ {query}", "Pussy g·ª≠i tr·∫£ 5 ·∫£nh")
    else:
        await update.message.reply_text("Kh√¥ng t√¨m th·∫•y ·∫£nh n√†o!")

async def news(update: Update, context: ContextTypes.DEFAULT_TYPE):
    if not await check_group_id(update, context):
        return
    query = " ".join(context.args)
    if not query:
        await update.message.reply_text("Vui l√≤ng nh·∫≠p t·ª´ kh√≥a sau l·ªánh /news")
        return
    await update.message.reply_text(f"ƒêang t√¨m ki·∫øm tin t·ª©c v·ªÅ '{query}'...")
    categories = ["general", "business", "technology", "science", "health", "sports", "entertainment"]
    news = get_news_info(query, query if query in categories else False)
    if isinstance(news, list):
        for article in news:
            response = f"üì∞ *{article['title']}*\n\n{article['content'][:300]}...\n\nNgu·ªìn: {article['source']}\nNg√†y ƒëƒÉng: {article['published_at']}\nLink: {article['url']}"
            response = escape_markdown(response)
            await context.bot.send_message(chat_id=update.message.chat_id, text=response, parse_mode='MarkdownV2')
    else:
        await update.message.reply_text(news)

def escape_markdown(text):
    # h√†m n√†y ƒë·ªÉ fix l·ªói markdown 
    if text is None:
        return ""
    # Tho√°t c√°c k√Ω t·ª± ƒë·∫∑c bi·ªát
    escape_chars = r'\_*[]()~`>#+-=|{}.!'
    return ''.join(f'\\{c}' if c in escape_chars else c for c in text)

async def crypto(update: Update, context: ContextTypes.DEFAULT_TYPE):
    if not await check_group_id(update, context):
        return
    coin = " ".join(context.args).lower()
    if not coin:
        await update.message.reply_text("Nh·∫≠p t√™n coin ƒëi tml, v√≠ d·ª•: /crypto bitcoin")
        return
    
    user_id = update.message.from_user.id
    group_id = update.message.chat_id
    user_name = track_id(user_id)
    
    url = f"{COINGECKO_API}/coins/{coin}?localization=false&tickers=false&market_data=true&community_data=false&developer_data=false&sparkline=false"
    response = requests.get(url)
    data = response.json()
    
    if "error" in data or "id" not in data:
        await update.message.reply_text(f"ƒê√©o t√¨m th·∫•y coin '{coin}' n√†o c·∫£! Check l·∫°i t√™n coin ƒëi tml.")
        return
    
    today = datetime.now().strftime("%d/%m/%Y")
    market_data = data["market_data"]
    price = market_data["current_price"]["usd"]
    volume_24h = market_data["total_volume"]["usd"]
    market_cap = market_data["market_cap"]["usd"]
    price_change_24h = market_data["price_change_percentage_24h"]
    high_24h = market_data["high_24h"]["usd"]
    low_24h = market_data["low_24h"]["usd"]
    last_updated = market_data["last_updated"]
    
    greed_fear_url = "https://api.alternative.me/fng/?limit=1"
    greed_fear_response = requests.get(greed_fear_url)
    greed_fear_data = greed_fear_response.json()
    
    if greed_fear_data and "data" in greed_fear_data and len(greed_fear_data["data"]) > 0:
        greed_fear_value = greed_fear_data["data"][0]["value"]
        greed_fear_classification = greed_fear_data["data"][0]["value_classification"]
        greed_fear_timestamp = greed_fear_data["data"][0]["timestamp"]
        greed_fear_text = f"üò® Ch·ªâ s·ªë S·ª£ h√£i & Tham lam (Greed/Fear): {greed_fear_value} - {greed_fear_classification} (C·∫≠p nh·∫≠t: {datetime.fromtimestamp(int(greed_fear_timestamp)).strftime('%Y-%m-%d %H:%M:%S')})"
    else:
        greed_fear_text = "üò® Kh√¥ng l·∫•y ƒë∆∞·ª£c ch·ªâ s·ªë S·ª£ h√£i & Tham lam, ch·∫Øc API h·ªèng r·ªìi tml!"
    
    response_text = (
        f"üí∞ **{coin.upper()}** - C·∫≠p nh·∫≠t l√∫c: {last_updated}\n"
        f"üìà Gi√° hi·ªán t·∫°i: ${price:,.2f}\n"
        f"üìä Thay ƒë·ªïi 24h: {price_change_24h:.2f}%\n"
        f"üîù Cao nh·∫•t 24h: ${high_24h:,.2f}\n"
        f"üîª Th·∫•p nh·∫•t 24h: ${low_24h:,.2f}\n"
        f"üí∏ V·ªën h√≥a th·ªã tr∆∞·ªùng: ${market_cap:,.0f}\n"
        f"üìâ Kh·ªëi l∆∞·ª£ng giao d·ªãch 24h: ${volume_24h:,.0f}\n"
        f"{greed_fear_text}"
    )
    
    await update.message.reply_text(response_text)
    await conversation_manager.add_message(group_id, user_id, user_name, f"T√¨m th√¥ng tin ƒë·ªìng coin, c·∫≠p nh·∫≠t {today}", response_text)

# async def macro(update: Update, context: ContextTypes.DEFAULT_TYPE):
#     from api import get_fred_data
#     if not await check_group_id(update, context):
#         return
#
#     user_id = update.message.from_user.id
#     group_id = update.message.chat_id
#     user_name = track_id(user_id)
#     await update.message.reply_text("ƒê·ª£i tao moi d·ªØ li·ªáu kinh t·∫ø vƒ© m√¥ t·ª´ FRED, tml ƒë·ª´ng h·ªëi!")
#
#     macro_data = []
#     macro_values = {}
#
#     indicators = [
#         ("GDPC1", "GDP th·ª±c t·∫ø (t·ª∑ USD)", "üìà"),
#         ("CPIAUCSL", "Ch·ªâ s·ªë gi√° ti√™u d√πng (CPI)", "üí∏"),
#         ("FEDFUNDS", "L√£i su·∫•t Fed (%)", "üè¶"),
#         ("UNRATE", "T·ª∑ l·ªá th·∫•t nghi·ªáp (%)", "üë∑‚Äç‚ôÇÔ∏è"),
#         ("PAYEMS", "B·∫£ng l∆∞∆°ng phi n√¥ng nghi·ªáp (ngh√¨n ng∆∞·ªùi)", "üíº"),
#         ("RSAFS", "Doanh s·ªë b√°n l·∫ª (tri·ªáu USD)", "üõí"),
#         ("INDPRO", "S·∫£n xu·∫•t c√¥ng nghi·ªáp", "üè≠"),
#         ("CPILFESL", "L·∫°m ph√°t l√µi (Core CPI)", "üî•"),
#         ("DGS10", "L·ª£i su·∫•t tr√°i phi·∫øu 10 nƒÉm (%)", "üìú"),
#         ("BOPGSTB", "C√°n c√¢n th∆∞∆°ng m·∫°i (tri·ªáu USD)", "‚öñÔ∏è"),
#         ("UMCSENT", "Ni·ªÅm tin ti√™u d√πng", "üòä")
#     ]
#
#     for series_id, name, icon in indicators:
#         text, value, date = get_fred_data(series_id, name, icon)
#         macro_data.append(text)
#         if value is not None:
#             macro_values[name] = {"value": value, "date": date}
#
#     response_text = (
#         "üìä **CH·ªà S·ªê KINH T·∫æ Vƒ® M√î T·ª™ FRED** - D·ªØ li·ªáu m·ªõi nh·∫•t:\n\n" +
#         "\n".join(macro_data))
#     await update.message.reply_text(response_text)
#     await conversation_manager.add_message(group_id, user_id, user_name, "D·ªØ li·ªáu kinh t·∫ø vƒ© m√¥", response_text)

async def handle_text(update: Update, context: ContextTypes.DEFAULT_TYPE):
    if not await check_group_id(update, context):
        return
    if not update.message.forward_origin:
        return
    if update.message.text:
        text = update.message.text
    else: 
        return
    user_id = update.message.from_user.id
    group_id = update.message.chat_id
    user_name = track_id(user_id)
    if user_name == -1:
        await update.message.reply_text(f"(ID: {user_id})\n\nƒê√¢y l√† l·∫ßn ƒë·∫ßu ti√™n tao n√≥i chuy·ªán v·ªõi m√†y, m√†y ch·ªù tao c·∫≠p nh·∫≠t c∆° s·ªü d·ªØ li·ªáu ƒë√£ nh√©!")
        return
    question = f"{user_name} forward n·ªôi dung t·ª´ n∆°i kh√°c, k√™u Pussy ph√¢n t√≠ch: {text}"
    response = await chatbot(question, group_id, user_id)
    await conversation_manager.add_message(group_id, user_id, user_name, question, response)
    await update.message.reply_text(response)

async def handle_photo_or_text(update: Update, context: ContextTypes.DEFAULT_TYPE):
    if not await check_group_id(update, context):
        return
    user_id = update.message.from_user.id
    group_id = update.message.chat_id
    user_name = track_id(user_id)
    if user_name == -1:
        await update.message.reply_text(f"(ID: {user_id})\n\nƒê√¢y l√† l·∫ßn ƒë·∫ßu ti√™n tao n√≥i chuy·ªán v·ªõi m√†y, m√†y ch·ªù tao c·∫≠p nh·∫≠t c∆° s·ªü d·ªØ li·ªáu ƒë√£ nh√©!")
        return
    if update.message.forward_origin:
        if update.message.caption:
            text = update.message.caption
            question = f"{user_name} forward n·ªôi dung t·ª´ n∆°i kh√°c, k√™u Pussy ph√¢n t√≠ch: {text}"
            response = await chatbot(question, group_id, user_id)
            await conversation_manager.add_message(group_id, user_id, user_name, question, response)
            await update.message.reply_text(response)
            return
        else: 
            return 
    photo_file = await update.message.photo[-1].get_file()
    photo_url = photo_file.file_path
    result = await analyze_image(image_url=photo_url)
    context = update.message.caption if update.message.caption else ""
    question = f"{user_name} k√™u m√†y (ch√≠nh l√† con m√®o Pussy) ph√¢n t√≠ch ·∫£nh k√®m context {context}, v√¨ Pussy kh√¥ng nh·∫≠n di·ªán ƒë∆∞·ª£c ·∫£nh n√™n ph·∫£i nh·ªù gemini m√¥ t·∫£: {result}."
    response = await chatbot(question, group_id, user_id)
    await conversation_manager.add_message(group_id, user_id, user_name, question, response)
    await update.message.reply_text(response)
